<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="http://www.example.com/SwerveDrive/swerveMath/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>Swerve Math - Ragnorok Robotics 3748 Swerve</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Swerve Math";
        var mkdocs_page_input_path = "SwerveDrive\\swerveMath.md";
        var mkdocs_page_url = "/SwerveDrive/swerveMath/";
      </script>
    
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../..">
          <img src="../../logo.png" class="logo" alt="Logo"/>
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Overview</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Swerve</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../">Swerve Overview</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Swerve Math</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#what-does-the-math-do">What does the math do?</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#notes-on-units">Notes on Units</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#getting-the-velocities-for-the-wheels">Getting the Velocities for the Wheels</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#translation">Translation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#rotation">Rotation</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#combining-rotation-and-translation">Combining Rotation and Translation</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#field-oriented-control">Field Oriented Control</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#why-use-field-oriented-control">Why use Field Oriented Control?</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#math-for-field-oriented-control">Math for Field-Oriented Control</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#summary">Summary</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../drivetrainSubsystem/">The Drivetrain Subsystem</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../logging/">Logging Workflow</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../auto/">Autonomous Workflow</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Ragnorok Robotics 3748 Swerve</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">Swerve</li>
      <li class="breadcrumb-item active">Swerve Math</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="swerve-math">Swerve Math</h1>
<h3 id="what-does-the-math-do">What does the math do?</h3>
<p>The math for swerve is concerned with translating "robot actions" to "wheel actions." That is, if you want the robot to move at 3m/s forward while rotation at 0.5rad/s, then the job of the math is to figure out how to move each wheel on the drivetrain to achieve that motion.</p>
<h3 id="notes-on-units">Notes on Units</h3>
<p>We will be using degrees, since they're the most intuitive. Angles will be measures as on the unit circle. If you are confused look up what the unit circle is. Also, the x-axis will be forward, so whenever I say the robot will drive forward, I mean that it will drive in the x-positive direction.</p>
<h2 id="getting-the-velocities-for-the-wheels">Getting the Velocities for the Wheels</h2>
<h3 id="translation">Translation</h3>
<p>Let's say for example that you want the robot to only move forward. That's pretty simple, you just make it point all the wheels forward and spin them forward. Now what if you want to move the robot at a 45 degree angle? That's also fairly easy: just point all the wheel to 45 degrees and spin the wheels forward. So, translation(moving the robot without rotating) is pretty simple for swerve: given a target angle and speed, the angle of each wheel should equal the target angle, and the wheels should spin at the target speed.</p>
<p><img alt="Diagram of Tranlation of Swerve Drive" src="../images/swerveTranslationDiagram.png" /></p>
<p>Therefore, if given a target velocity vector <span class="arithmatex">\(v\)</span>, the velocities for each wheel will be given by the following equation:
$$
v_i = v
$$
Pretty Simple. 
(Note: If you don't know what a velocity vector is, look at some of the videos <a href="https://www.khanacademy.org/science/ap-college-physics-1/xf557a762645cccc5:kinematics-and-introduction-to-dynamics">here</a>)</p>
<h3 id="rotation">Rotation</h3>
<p>What if you want the drivetrain to rotate at a certain speed clockwise/counter-clockwise? To think about this, we will draw an imaginary circle that the wheels lie on in the chassis, as shown below:</p>
<p><img alt="Swerve Diagram" src="../images/swerveDiagram.png" /></p>
<p>To rotate the robot, the wheels just need to point tangent to this circle and spin, as shown:</p>
<p><img alt="Diagram of wheel rotations" src="../images/swerveMathWheelRotation.png" /></p>
<p>But how do you control the speed at which the robot spins? Well, to answer this, we need to translate the target rotational velocity to a linear velocity (since the speed of each wheel at the edge of the circle is the linear speed). Spinning the wheels at this speed should rotate the robot at the target rotational velocity. The equation to translate the velocities is as follows:
$$
v_i = \omega R
$$</p>
<ul>
<li><span class="arithmatex">\(\omega\)</span> is the target rotational velocity</li>
<li><span class="arithmatex">\(R\)</span> is the distance of the wheels from the center of the chassis</li>
<li><span class="arithmatex">\(v_i\)</span> is the velocity of each wheel</li>
</ul>
<p>However, there is a problem with this: it only takes into account one dimension; <span class="arithmatex">\(R\)</span> is just one number, so if you have an irregularly shaped chassis, the equation won't work. The bigger problem is that later, when we try to combine rotational and translational motion, we will need the output of the equation to be a vector for each wheel, however, this only returns a scalar(a number that doesn't indicate direction). So instead, we will use this equation
$$
v_i = \omega \times R_i
$$</p>
<p>It's a very subtle change, but <span class="arithmatex">\(v_i\)</span> will be the cross product of <span class="arithmatex">\(\omega\)</span> and <span class="arithmatex">\(R_i\)</span> where both <span class="arithmatex">\(\omega\)</span> and <span class="arithmatex">\(R_i\)</span> can be vectors. This keeps the output, <span class="arithmatex">\(v_i\)</span>, as a vector. Also note that instead of <span class="arithmatex">\(R\)</span>, we will be using <span class="arithmatex">\(R_i\)</span>, which will represent the coordinates of each wheel relative to the robot's center. So if one of the wheels is 0.75m to the right and 0.5m up from the center of the robot, <span class="arithmatex">\(R_i\)</span> will be <span class="arithmatex">\(\begin{bmatrix} 0.75 \\ 0.5 \end{bmatrix}\)</span>.</p>
<h3 id="combining-rotation-and-translation">Combining Rotation and Translation</h3>
<p>In a competition, you won't just be doing rotation or translation, you'll be doing a combination of both. So we will need an equation that gives the velocity for each wheel given a target velocity for translation and a target rotational velocity. It turns out this is pretty simple: we just combine the two equations from the previous sections:
$$
v_i = v + \omega \times R_i
$$</p>
<p>This formula is the core of the drivetrain. Just to review, here is what all the symbols mean:</p>
<ul>
<li><span class="arithmatex">\(v_i\)</span> is the velocity of the <span class="arithmatex">\(i\)</span>th wheel.</li>
<li><span class="arithmatex">\(v\)</span> is the target translational velocity for the robot.</li>
<li><span class="arithmatex">\(\omega\)</span> is the rotational velocity for the robot.</li>
<li><span class="arithmatex">\(R_i\)</span> is the distance from the center of the robot to the <span class="arithmatex">\(i\)</span>th wheel.</li>
</ul>
<p>All of this might be confusing if you have never been exposed to kinematics, so take a moment to make sure you understand everything and ask questions in the discord if you have them.</p>
<p>Note that <span class="arithmatex">\(v_i\)</span> is going to be a 2D vector that indicates the velocity of the <span class="arithmatex">\(i\)</span>th wheel, but it is going to be helpful to split the equation for <span class="arithmatex">\(v_i\)</span> so that we have two equations that output scalars(we need to isolate x and y components.</p>
<p><img alt="Drawing of vi components" src="../images/viComponents.png" /></p>
<p>So the equations for the x and y components will be as follows(look at <a href="https://www.mathsisfun.com/algebra/vectors-cross-product.html">this page</a> for how these could be derived):
$$
\displaylines{
v_{ix} = v_x - \omega R_{iy} \newline
v_{iy} = v_y + \omega R_{ix}
}
$$</p>
<p><span class="arithmatex">\(\omega\)</span> is the target rotational speed. Here is a diagram that illustrates what all the other symbols are:
<img alt="omega_drawing" src="../images/omegaDrawing.png" /></p>
<h2 id="field-oriented-control">Field Oriented Control</h2>
<h3 id="why-use-field-oriented-control">Why use Field Oriented Control?</h3>
<p>When controlling a swerve drivetrain, it is very helpful to dissociate the turning with the translation motion. However, this means that the driver would need to constantly adjust for how the robot is turned. So, if the robot is turned 180 degrees, the driver would need to go "back" to drive forward. This is very hard to do during a competition, so it is better to have the robot use field-oriented control, where a command to drive "forward" will always move the robot away from the driver.</p>
<h3 id="math-for-field-oriented-control">Math for Field-Oriented Control</h3>
<p>We need two things to achieve field oriented control: an input(<span class="arithmatex">\(\vec{v}\)</span>; the driver gives through the controller), and the robot rotation relative to the field(<span class="arithmatex">\(\theta\)</span> ; we get this from the gyro). The input vector can be represented as so:
$$
\vec{v} = \begin{bmatrix}
v_x \newline
v_y
\end{bmatrix}
$$
where:</p>
<ul>
<li><span class="arithmatex">\(\vec{v}\)</span> is the target velocity vector of the robot</li>
<li><span class="arithmatex">\(v_x\)</span> is the field oriented <span class="arithmatex">\(x\)</span>-velocity of the robot</li>
<li><span class="arithmatex">\(v_y\)</span> is the field oriented y-velocity of the robot</li>
</ul>
<p>In order for the robot to always move relative to the field rather than itself, we need to rotate the field commands by the inverse of the robot rotation. For instance, if the driver wants the robot to move forward, the input vector for that might look like <span class="arithmatex">\(\begin{bmatrix} 1 \\ 0 \end{bmatrix}\)</span>(remember the x-axis is forward). So, for the robot to always move relative to the field, the vector needs to be rotated opposite to the robot's rotation on the field. So, if the robot is rotated 45 degrees relative to the field(towards the left wall), the input vector needs to be rotated -45 degrees, so the forward input vector from before would now be <span class="arithmatex">\(\begin{bmatrix} .71 \\ .71 \end{bmatrix}\)</span> (notice that the magnitude of the vector -- the speed -- doesn't change):</p>
<p><img alt="fieldToRobot.png" src="../images/fieldToRobot.png" /></p>
<p>Therefore, for every field relative input that we get from the controller, we need to rotate it by the inverse of the robot rotation before feeding it through the kinematics to get the wheel velocities. This can be done with a rotation matrix. We have to multiply the field relative velocity vector <span class="arithmatex">\(v\)</span> with the rotation matrix to get the robot-relative velocity:</p>
<p>$$
\displaylines{
A=\begin{bmatrix}
cos(\theta) &amp;&amp; -sin(\theta) \newline
sin(\theta) &amp;&amp; cos(\theta)
\end{bmatrix} \hspace{1em}
v_{r} = Av
}
$$
where:</p>
<ul>
<li><span class="arithmatex">\(A\)</span> is the rotation matrix</li>
<li><span class="arithmatex">\(\theta\)</span> is the robot angle relative to the field</li>
<li><span class="arithmatex">\(v_r\)</span> is the field relative target velocity</li>
</ul>
<p>This math can be converted to scalar for so that it is easier to code:
$$
\displaylines{
v_{rx} = v_xcos(\theta) - v_xsin(\theta) \newline
v_{ry} = v_ysin(\theta) + v_ycos(\theta)
}
$$
where:</p>
<ul>
<li><span class="arithmatex">\(v_{rx}\)</span> is the <span class="arithmatex">\(x\)</span>-component of the robot relative target velocity</li>
<li><span class="arithmatex">\(v_{ry}\)</span> is the <span class="arithmatex">\(y\)</span>-component of the robot relative target velocity</li>
<li><span class="arithmatex">\(v_x\)</span> is the <span class="arithmatex">\(x\)</span>-component of the field relative target velocity</li>
<li><span class="arithmatex">\(v_y\)</span> is the <span class="arithmatex">\(y\)</span>-component of the field relative target velocity</li>
<li><span class="arithmatex">\(\theta\)</span> is the robot angle relative to the field</li>
</ul>
<h2 id="summary">Summary</h2>
<p>The inputs are first collected from the driver. These are essentially 3 numbers: the <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(y\)</span> components of the field-relative target velocity and the target rotational velocity <span class="arithmatex">\(\omega\)</span>. The <span class="arithmatex">\(x\)</span> and <span class="arithmatex">\(y\)</span> components can be represent as a vector <span class="arithmatex">\(\vec{v}\)</span>:
$$
\displaylines{
\vec{v} = \begin{bmatrix} 
v_x \newline 
v_y
\end{bmatrix}
}
$$
This <span class="arithmatex">\(\vec{v}\)</span> is then translated to the robot-relative target velocity as described in <a href="#math-for-field-oriented-control">this section</a>. The robot relative velocity and the <span class="arithmatex">\(\omega\)</span> from the driver inputs can be fed through the kinematics described <a href="#getting-the-velocities-for-the-wheels">here</a> to get the wheel velocities. Then PID controllers can be used to enforce these target velocities on each module.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../" class="btn btn-neutral float-left" title="Swerve Overview"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../drivetrainSubsystem/" class="btn btn-neutral float-right" title="The Drivetrain Subsystem">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
      <span><a href="../" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../drivetrainSubsystem/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "../..";</script>
    <script src="../../js/theme_extra.js"></script>
    <script src="../../js/theme.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="../../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
